<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>tinystr.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; </center>
<hr><h1>tinystr.h</h1><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment">www.sourceforge.net/projects/tinyxml</span>
00003 <span class="comment">Original file by Yves Berquin.</span>
00004 <span class="comment"></span>
00005 <span class="comment">This software is provided 'as-is', without any express or implied </span>
00006 <span class="comment">warranty. In no event will the authors be held liable for any </span>
00007 <span class="comment">damages arising from the use of this software.</span>
00008 <span class="comment"></span>
00009 <span class="comment">Permission is granted to anyone to use this software for any </span>
00010 <span class="comment">purpose, including commercial applications, and to alter it and </span>
00011 <span class="comment">redistribute it freely, subject to the following restrictions:</span>
00012 <span class="comment"></span>
00013 <span class="comment">1. The origin of this software must not be misrepresented; you must </span>
00014 <span class="comment">not claim that you wrote the original software. If you use this </span>
00015 <span class="comment">software in a product, an acknowledgment in the product documentation </span>
00016 <span class="comment">would be appreciated but is not required.</span>
00017 <span class="comment"></span>
00018 <span class="comment">2. Altered source versions must be plainly marked as such, and</span>
00019 <span class="comment">must not be misrepresented as being the original software.</span>
00020 <span class="comment"></span>
00021 <span class="comment">3. This notice may not be removed or altered from any source </span>
00022 <span class="comment">distribution.</span>
00023 <span class="comment">*/</span>
00024 
00025 <span class="preprocessor">#include "tinyxml.h"</span>
00026 
00027 
00028 <span class="preprocessor">#ifndef TIXML_USE_STL</span>
00029 <span class="preprocessor"></span>
00030 <span class="preprocessor">#ifndef TIXML_STRING_INCLUDED</span>
00031 <span class="preprocessor"></span><span class="preprocessor">#define TIXML_STRING_INCLUDED</span>
00032 <span class="preprocessor"></span>
00033 <span class="preprocessor">#ifdef _MSC_VER</span>
00034 <span class="preprocessor"></span><span class="preprocessor">#pragma warning( disable : 4786 )   // Debugger truncating names.</span>
00035 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00036 <span class="preprocessor"></span>
00037 <span class="preprocessor">#include &lt;assert.h&gt;</span>
00038 
00039 <span class="comment">/*</span>
00040 <span class="comment">   TiXmlString is an emulation of the std::string template.</span>
00041 <span class="comment">   Its purpose is to allow compiling TinyXML on compilers with no or poor STL support.</span>
00042 <span class="comment">   Only the member functions relevant to the TinyXML project have been implemented.</span>
00043 <span class="comment">   The buffer allocation is made by a simplistic power of 2 like mechanism : if we increase</span>
00044 <span class="comment">   a string and there's no more room, we allocate a buffer twice as big as we need.</span>
00045 <span class="comment">*/</span>
00046 <span class="keyword">class </span>TiXmlString
00047 {
00048   <span class="keyword">public</span> :
00049     <span class="comment">// TiXmlString constructor, based on a string</span>
00050     TiXmlString (<span class="keyword">const</span> <span class="keywordtype">char</span> * instring);
00051 
00052     <span class="comment">// TiXmlString empty constructor</span>
00053     TiXmlString ()
00054     {
00055         allocated = 0;
00056         cstring = NULL;
00057         current_length = 0;
00058     }
00059 
00060     <span class="comment">// TiXmlString copy constructor</span>
00061     TiXmlString (<span class="keyword">const</span> TiXmlString&amp; copy);
00062 
00063     <span class="comment">// TiXmlString destructor</span>
00064     ~ TiXmlString ()
00065     {
00066         empty_it ();
00067     }
00068 
00069     <span class="comment">// Convert a TiXmlString into a classical char *</span>
00070     <span class="keyword">const</span> <span class="keywordtype">char</span> * c_str ()<span class="keyword"> const</span>
00071 <span class="keyword">    </span>{
00072         <span class="keywordflow">if</span> (allocated)
00073             <span class="keywordflow">return</span> cstring;
00074         <span class="keywordflow">return</span> <span class="stringliteral">""</span>;
00075     }
00076 
00077     <span class="comment">// Return the length of a TiXmlString</span>
00078     <span class="keywordtype">unsigned</span> length ()<span class="keyword"> const</span>
00079 <span class="keyword">    </span>{
00080         <span class="keywordflow">return</span> ( allocated ) ? current_length : 0;
00081     }
00082 
00083     <span class="comment">// TiXmlString = operator</span>
00084     <span class="keywordtype">void</span> operator = (<span class="keyword">const</span> <span class="keywordtype">char</span> * content);
00085 
00086     <span class="comment">// = operator</span>
00087     <span class="keywordtype">void</span> operator = (<span class="keyword">const</span> TiXmlString &amp; copy);
00088 
00089     <span class="comment">// += operator. Maps to append</span>
00090     TiXmlString&amp; operator += (<span class="keyword">const</span> <span class="keywordtype">char</span> * suffix)
00091     {
00092         append (suffix);
00093         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00094     }
00095 
00096     <span class="comment">// += operator. Maps to append</span>
00097     TiXmlString&amp; operator += (<span class="keywordtype">char</span> single)
00098     {
00099         append (single);
00100         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00101     }
00102 
00103     <span class="comment">// += operator. Maps to append</span>
00104     TiXmlString&amp; operator += (TiXmlString &amp; suffix)
00105     {
00106         append (suffix);
00107         <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00108     }
00109     <span class="keywordtype">bool</span> operator == (<span class="keyword">const</span> TiXmlString &amp; compare) <span class="keyword">const</span>;
00110     <span class="keywordtype">bool</span> operator &lt; (<span class="keyword">const</span> TiXmlString &amp; compare) <span class="keyword">const</span>;
00111     <span class="keywordtype">bool</span> operator &gt; (<span class="keyword">const</span> TiXmlString &amp; compare) <span class="keyword">const</span>;
00112 
00113     <span class="comment">// Checks if a TiXmlString is empty</span>
00114     <span class="keywordtype">bool</span> empty ()<span class="keyword"> const</span>
00115 <span class="keyword">    </span>{
00116         <span class="keywordflow">return</span> length () ? <span class="keyword">false</span> : <span class="keyword">true</span>;
00117     }
00118 
00119     <span class="comment">// single char extraction</span>
00120     <span class="keyword">const</span> <span class="keywordtype">char</span>&amp; at (<span class="keywordtype">unsigned</span> index)<span class="keyword"> const</span>
00121 <span class="keyword">    </span>{
00122         assert( index &lt; length ());
00123         <span class="keywordflow">return</span> cstring [index];
00124     }
00125 
00126     <span class="comment">// find a char in a string. Return TiXmlString::notfound if not found</span>
00127     <span class="keywordtype">unsigned</span> find (<span class="keywordtype">char</span> lookup)<span class="keyword"> const</span>
00128 <span class="keyword">    </span>{
00129         <span class="keywordflow">return</span> find (lookup, 0);
00130     }
00131 
00132     <span class="comment">// find a char in a string from an offset. Return TiXmlString::notfound if not found</span>
00133     <span class="keywordtype">unsigned</span> find (<span class="keywordtype">char</span> tofind, <span class="keywordtype">unsigned</span> offset) <span class="keyword">const</span>;
00134 
00135     <span class="comment">/*  Function to reserve a big amount of data when we know we'll need it. Be aware that this</span>
00136 <span class="comment">        function clears the content of the TiXmlString if any exists.</span>
00137 <span class="comment">    */</span>
00138     <span class="keywordtype">void</span> reserve (<span class="keywordtype">unsigned</span> size)
00139     {
00140         empty_it ();
00141         <span class="keywordflow">if</span> (size)
00142         {
00143             allocated = size;
00144             cstring = <span class="keyword">new</span> <span class="keywordtype">char</span> [size];
00145             cstring [0] = 0;
00146             current_length = 0;
00147         }
00148     }
00149 
00150     <span class="comment">// [] operator </span>
00151     <span class="keywordtype">char</span>&amp; operator [] (<span class="keywordtype">unsigned</span> index)<span class="keyword"> const</span>
00152 <span class="keyword">    </span>{
00153         assert( index &lt; length ());
00154         <span class="keywordflow">return</span> cstring [index];
00155     }
00156 
00157     <span class="comment">// Error value for find primitive </span>
00158     <span class="keyword">enum</span> {  notfound = 0xffffffff,
00159             npos = notfound };
00160 
00161     <span class="keywordtype">void</span> append (<span class="keyword">const</span> <span class="keywordtype">char</span> *str, <span class="keywordtype">int</span> len );
00162 
00163   <span class="keyword">protected</span> :
00164 
00165     <span class="comment">// The base string</span>
00166     <span class="keywordtype">char</span> * cstring;
00167     <span class="comment">// Number of chars allocated</span>
00168     <span class="keywordtype">unsigned</span> allocated;
00169     <span class="comment">// Current string size</span>
00170     <span class="keywordtype">unsigned</span> current_length;
00171 
00172     <span class="comment">// New size computation. It is simplistic right now : it returns twice the amount</span>
00173     <span class="comment">// we need</span>
00174     <span class="keywordtype">unsigned</span> assign_new_size (<span class="keywordtype">unsigned</span> minimum_to_allocate)
00175     {
00176         <span class="keywordflow">return</span> minimum_to_allocate * 2;
00177     }
00178 
00179     <span class="comment">// Internal function that clears the content of a TiXmlString</span>
00180     <span class="keywordtype">void</span> empty_it ()
00181     {
00182         <span class="keywordflow">if</span> (cstring)
00183             <span class="keyword">delete</span> [] cstring;
00184         cstring = NULL;
00185         allocated = 0;
00186         current_length = 0;
00187     }
00188 
00189     <span class="keywordtype">void</span> append (<span class="keyword">const</span> <span class="keywordtype">char</span> *suffix );
00190 
00191     <span class="comment">// append function for another TiXmlString</span>
00192     <span class="keywordtype">void</span> append (<span class="keyword">const</span> TiXmlString &amp; suffix)
00193     {
00194         append (suffix . c_str ());
00195     }
00196 
00197     <span class="comment">// append for a single char.</span>
00198     <span class="keywordtype">void</span> append (<span class="keywordtype">char</span> single)
00199     {
00200         <span class="keywordflow">if</span> ( cstring &amp;&amp; current_length &lt; (allocated-1) )
00201         {
00202             cstring[ current_length ] = single;
00203             ++current_length;
00204             cstring[ current_length ] = 0;
00205         }
00206         <span class="keywordflow">else</span>
00207         {
00208             <span class="keywordtype">char</span> smallstr [2];
00209             smallstr [0] = single;
00210             smallstr [1] = 0;
00211             append (smallstr);
00212         }
00213     }
00214 
00215 } ;
00216 
00217 <span class="comment">/* </span>
00218 <span class="comment">   TiXmlOutStream is an emulation of std::ostream. It is based on TiXmlString.</span>
00219 <span class="comment">   Only the operators that we need for TinyXML have been developped.</span>
00220 <span class="comment">*/</span>
00221 <span class="keyword">class </span>TiXmlOutStream : <span class="keyword">public</span> TiXmlString
00222 {
00223 <span class="keyword">public</span> :
00224     TiXmlOutStream () : TiXmlString () {}
00225 
00226     <span class="comment">// TiXmlOutStream &lt;&lt; operator. Maps to TiXmlString::append</span>
00227     TiXmlOutStream &amp; operator &lt;&lt; (<span class="keyword">const</span> <span class="keywordtype">char</span> * in)
00228     {
00229         append (in);
00230         <span class="keywordflow">return</span> (* this);
00231     }
00232 
00233     <span class="comment">// TiXmlOutStream &lt;&lt; operator. Maps to TiXmlString::append</span>
00234     TiXmlOutStream &amp; operator &lt;&lt; (<span class="keyword">const</span> TiXmlString &amp; in)
00235     {
00236         append (in . c_str ());
00237         <span class="keywordflow">return</span> (* this);
00238     }
00239 } ;
00240 
00241 <span class="preprocessor">#endif  // TIXML_STRING_INCLUDED</span>
00242 <span class="preprocessor"></span><span class="preprocessor">#endif  // TIXML_USE_STL</span>
</pre></div><hr><address style="align: right;"><small>Generated on Sat May 22 22:12:26 2004 for TinyXml by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>
